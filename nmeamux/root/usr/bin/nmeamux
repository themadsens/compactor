#!/usr/bin/env amplua
--[[
 - @file nmeamux
 - ABSTRACT HERE << 
 -
 - $Id$
 -
 - (C) Copyright 2011 Amplex, fm@amplex.dk
--]]

require "stdlib" .include { "seq" }
require "posix"
require "socket"
require "Class"
local NIL = Class.NIL

local L_OPEN_RETRY = 5 * 1000

local NmeaNode = Class("NmeaNode", nil, {
   mName = NIL,
   mInputs = NIL,
   mSinks = NIL,
   mPortNo = NIL,
   mPortSock = NIL,
   mListeners = NIL,
   mSubscriptions = NIL,
})

local NmeaFilter = Class("NmeaFilter", NmeaNode, {
   mPosList = NIL,
   mNegList = NIL,
   mAuxList = NIL,
   mPrioTout = NIL,
   mPrioList = NIL,
})

local NmeaPort = Class("NmeaPort", NmeaNode, {
   mPath = NIL,
   mSpeed = NIL,
   mDutyIn = NIL,
   mDutyOut = NIL,
   mSerialPort = NIL,
   mLineBuffer = NIL,
})

local RawPort = Class("RawPort", NmeaPort, {})

local NmeaOutput = Class("NmeaOutput", NmeaNode, {
   mOutput = NIL,
})

local NilFilter = Class("NilFilter", nil, {})
local AisFilter = Class("AisFilter", NilFilter, {mDb = NIL})
local GpsComp = Class("GpsComp", NilFilter, {mDb = NIL})

local DutyCycle = Class("DutyCycle", nil, {
   mSpeed = NIL,
   mTail = NIL,
})

function DutyCycle.new(class, speed)
   return class:_new { mSpeed = speed }
end
function DutyCycle.addLen() end

local testConf
-- [[
= {
   outputs = {
      testout      = { inputs = { "testfilter" },  output = "rawport",    port=27002 }, 
   },
   nmeaports = {
      testgps      = { path = "/dev/ttyUSB0",                     speed=4800  , port=26001},
      testport     = { path = "/dev/ttyUSB1",                     speed=4800  , port=26001},
   },
   rawports = {
      rawport      = { path = "/dev/ttyUSB2",                     speed=38400 , port=25006},
   },
   filter   = {
      testfilter       = { inputs = { "testport", "testgps" }                 , port=28001,
                           neg = { "^%$..GGA", }, prio_delay=2500, aux = {AisFilter} },
   },
}
--]]

local sampleConf = {
   outputs = {
      instruments = { inputs = {"p_lospeed_1", "nogps_bkhousemux", "autopilot"}, port=27001,
                      output = "p_lospeed_1" },
      --sfeed     = { inputs = { "gps_bkhousemux" },  output = "p_lospeed_2",    port=27002 }, 
      gpsfeed     = { inputs = { "gps" },             output = "p_lospeed_2",    port=27002 }, 
      garmin_nmea = { inputs = { "p_lospeed_1", "p_lospeed_2", "p_ais", "p_bkhousemux" },
                      output = "p_hispeed",                                      port=27003 },
   },
   nmeaports = {
      p_lospeed_1  = { path = "/dev/ttyusb/mos7840-9710-7840/0",  speed=4800  , port=26001},
      p_lospeed_2  = { path = "/dev/ttyusb/mos7840-9710-7840/1",  speed=4800  , port=26002},
      p_hispeed    = { path = "/dev/ttyusb/mos7840-9710-7840/2",  speed=38400 , port=26003},
      p_gps        = { path = "/dev/ttyusb/pl2303-067b-2303/bus_usb_001_004",
                                                                  speed=4800  , port=26004},
      p_ais        = { path = "/dev/ttyusb/ftdi_sio-0403-6001/0", speed=38400 , port=25001},
      p_bkhousemux = { path = "/dev/ttyusb/BROOKHOUSE10-7840/3",  speed=38400 , port=25005},
   },
   rawports = {
      p_pactor     = { path = "/dev/ttyusb/ftdi_sio-0403-d010/0", speed=9600  , port=25002},
      p_garmin1    = { path = "/dev/ttyusb/mos7840-9710-7840/3",  speed=9600  , port=25003},
      p_garmin2    = { path = "/dev/ttyS0",                       speed=9600  , port=25004},
      p_navtex     = { path = "/dev/ttyusb/pl2303-067b-2303/bus_usb_001_011",
                                                                  speed=38400 , port=25006},
   },
   filter   = {
      nogps_bkhousemux = { inputs = { "p_bkhousemux" }                        , port=28001,
                           neg = { "^%$..GGA", "^%$..GSA", "^%$..GSV", } },
      gps_bkhousemux   = { inputs = { "p_gps", "p_bkhousemux", "aisfilter"}   , port=28002,
                           pos = { "^%$..GGA", "^%$..GSA", "^%$..RMC", "^%$..GSV", },
                           aux={GpsComp}, prio_delay=2500 },
      autopilot =        { inputs = { "p_hispeed" }                           , port=28003, 
                           pos = { "%$..XTE", "%$..WPT" } },
      aisfilter =        { inputs = { "p_ais" }                               , port=28004, 
                           aux = {AisFilter} }
   },
}

local nodes = {}
local sysmon
local sysstat= {} -- pos, sog, cog, stw, hdg, dpt, wrv, wrb, 

--------------------------------------------------------------------
-- NmeaNode
-- Handle node graph and telnet connections
--------------------------------------------------------------------

---
-- Create a generic node
function NmeaNode.new(_class, name, cfg)
   return _class:_new():_merge {
      mName = name,
      mInputs = cfg.inputs,
      mSinks = {}, 
      mPortNo = cfg.port,
      mListeners = {},
      mSubscriptions = {},
   }
end

---
-- Data forwarding
function NmeaNode:processInput(str)
   -- Simple relay
   for ix,s in pairs(self.mSinks) do
      s:processInput(str, ix)
   end
   for l,_ in pairs(self.mListeners) do
      l:send(str)
   end
end

---
-- Register a data sink
function NmeaNode:addSink(new)
   -- Simple relay
   self.mSinks[new.mName] = new
end

---
-- Read input from a connected peer.
-- Override and embed in derived classes to read input
function NmeaNode:readClient(subscr, inp)
   local res, err = posix.read(inp:getfd())
   if not res then
      log.notice(("PORT:%-15s Connection %d closed"):_(self.mName, inp:getfd()))
      self.mListeners[inp] = nil
      self.mSubscriptions[subscr] = nil
      subscr:clear()
      return nil
   end
   return res
end

---
-- Startup system interaction
function NmeaNode:start(str)
   for _,s in ipairs(self.mSinks or {}) do
      nodes[s]:addSink(s)
   end
   if not self.mPortNo then return end

   self.mPortSock = socket.bind("0.0.0.0", self.mPortNo)
   local subscr = appc.addFileIO(self.mPortSock:getfd(), function(subscr)
      local inp = self.mPortSock:accept()
      log.notice(("PORT:%-15s Connection %d opened from %s"):
                _(self.mName, inp:getfd(), inp:getpeername()))
      local subscr = appc.addFileIO(inp:getfd(), function(subscr) self:readClient(subscr, inp) end)
      self.mSubscriptions[subscr] = true
      self.mListeners[inp] = true
   end)
   self.mSubscriptions[subscr] = true
end

---
-- Cleanup subscriptions & listeners
function NmeaNode:clear()
   for l,_ in pairs(self.mSubscriptions) do l:clear() end
   for l,_ in pairs(self.mListeners) do l:close() end
   self.mSubscriptions = NIL
   self.mListeners = NIL
   if self.mPortSock then self.mPortSock:close() end
   self.mPortSock = nil
end
function NmeaNode:__gc() return self:clear() end

--------------------------------------------------------------------
-- NmeaOutput 
--------------------------------------------------------------------

---
-- Create an output node
function NmeaOutput.new(_class, name, cfg)
   return NmeaOutput:getSuper().new(_class, name, cfg):_merge {
      mOutput = assert(cfg.output)
   }
end

---
-- Startup system interaction
function NmeaOutput:start(str)
   NmeaOutput:getSuper().start(self, str)
   self:addSink(nodes[self.mOutput])
end

--------------------------------------------------------------------
-- NmeaPort 
--------------------------------------------------------------------

---
-- Create an output node
function NmeaPort.new(_class, name, cfg)
   return NmeaPort:getSuper().new(_class, name, cfg):_merge {
      mPath = assert(cfg.path),
      mSpeed = assert(cfg.speed),
      mDutyOut = DutyCycle(cfg.speed),
      mDutyIn = DutyCycle(cfg.speed),
      mLineBuffer = tnew {},
   }
end
function RawPort.new(_class, name, cfg)
   return NmeaPort.new(_class, name, cfg):_merge { mLineBuffer = nil }
end

---
-- Startup system interaction
function NmeaPort:start(str)
   NmeaPort:getSuper().start(self, str)
   return self:reOpen()
end

---
-- Startup system interaction
function NmeaPort:reOpen()
   local port, err = io.open(self.mPath, "rw")
   if not port then
      log.error(("PORT:%-15s Failed to open %s: %s"):_(self.mName, self.mPath, err))
      appc.addTimer(L_OPEN_RETRY, function() self:reOpen() end)
      return
   end
   self.mSerialPort = port
   os.execute(("stty %d raw -parenb cs8 < %s"):_(self.mSpeed, self.mPath))
   local subscr = appc.addFileIO(self.mSerialPort:getfd(), function(subscr) 
      local str, err = posix.read(port:getfd())
      if not str then
         log.error(("PORT:%-15s REOPEN: Failed to read %s: %s"):_(self.mName, self.mPath, err))
         self.mSerialPort:close()
         self.mSerialPort = nil
         subscr:clear()
         self.mSubscriptions[subscr] = nil
         appc.addTimer(L_OPEN_RETRY, function() self:reOpen() end)
         return
      end
      -- TODO: Reopen on error
      if self.mLineBuffer then
         local where = str:find("\r\n")
         if where then
            self.mLineBuffer:append(str:sub(1, where - 1))
            NmeaPort:getSuper().processInput(self, self.mLineBuffer:concat())
            self.mLineBuffer = tnew { str:sub(where + 2) }
         else
            self.mLineBuffer:append(str)
         end
      else
         NmeaPort:getSuper().processInput(self, str)
      end
   end)
   self.mSubscriptions[subscr] = true
end

---
-- Cleanup subscriptions & listeners
function NmeaPort:clear()
   NmeaPort:getSuper().clear(self)
   if self.mSerialPort then self.mSerialPort:close() end
   self.mSerialPort = nil
end


---
-- Data forwarding
function NmeaPort:processInput(str)
   self.mDutyOut:addLen(#str)
   self.mSerialPort:write(str)
   if self.mLineBuffer then sysmon:addOut(self, str:sub(1,6)) end
end

---
-- Read input from a connected peer.
function NmeaPort:readClient(subscr, inp)
   local str = NmeaPort:getSuper().readClient(self, subscr, inp)
   self:processInput(str)
end

--------------------------------------------------------------------
-- NmeaFilter 
--------------------------------------------------------------------

---
-- Create an output node
function NmeaFilter.new(_class, name, cfg)
   return NmeaFilter:getSuper().new(_class, name, cfg):_merge {
      mPosList = cfg.pos,
      mNegList = cfg.neg,
      mAuxList = cfg.aux,
      mPrioTout = cfg.prio_delay,
      mPrioList = {},
   }
end

---
-- Startup system interaction
function NmeaFilter:start(str)
   NmeaFilter:getSuper().start(self, str)
   self.mAuxList = List(seq.map(function(cls) return cls() end, self.mAuxList or {}))
end

---
-- Data forwarding
function NmeaFilter:processInput(str, ix)
   if self.mNegList then
      for _,p in ipairs(self.mNegList) do
         if p:find(str) then
            return
         end
      end
   end
   if self.mPosList then
      local pass
      for _,p in ipairs(self.mNegList) do
         if p:find(str) then
            pass = true
            break
         end
      end
      if not pass then
         return
      end
   end
   if self.mAuxList then
      for _,aux in ipairs(self.mAuxList) do
         aux:process(str, function(str) self:passItOn(str, ix) end)
      end
   else
      self:passItOn(str, ix)
   end
end

---
-- Implement priority shadowing
function NmeaFilter:passItOn(str, ix)
   if self.mPrioTout then
      local now, mSec = appc.systemTime()
      now = now * 1000 + mSec
      local stmt = str:sub(1,5)
      local old = self.mPrioList[stmt]
      if old and (now - old.timeStamp) < self.mPrioTout and old.prio < ix then
         return -- He wins
      end
      self.mPrioList[stmt] = { timeStamp = now, prio = ix }
   end
   return NmeaFilter:getSuper().processInput(self, str, ix)
end

--------------------------------------------------------------------
-- FILTERS
--------------------------------------------------------------------

function NilFilter:process(port, str, out)
   out(str)
end

--------------------------------------------------------------------
-- MONITOR
--------------------------------------------------------------------

local SysMon= Class("SysMon", nil, {
   mPort = NIL,
   mQueue = NIL,
   mTimer = NIL,
   mIndex = NIL,
})

function  SysMon:runTimer()
end

local SysMonTon = Class("SysMonTon", nil, {
   mSysMons = NIL,
   mNames = NIL,
   mListeners = NIL,
   mSocket = NIL,
})

function SysMonTon:openPort(port)
end

function SysMonTon:addIn(port, snt, out)
   local q = self.mSysMons[port].mQueue[out and 2 or 1]
   q:insert(snt)
   sysmon:LineStat(self.mSysMons[port], out)
   self.mSysMons[port]:runTimer()
end

function SysMonTon:addOut(port, snt)
   return self:addIn(port, snt, true)
end

function SysMonTon:addPort(port)
   if self.mSysMons[port] then return end

   self.mNames:insert(port.mName)
   self.mNames:sort()
   for ix,nm in ipairs(self.mNames) do
      if nm == port.mName then 
         self.mSysMons[port] = SysMon { mIndex = ix, mQueue = {{}, {}}, mPort = port }
      end
   end
end

local function startMonitor(port)
   sysmon = SysMonTon { mSysMons = {}, mListeners = {}, mNames = tnew {} }
   sysmon:openPort(port)
end

--------------------------------------------------------------------
-- SYSTEM
--------------------------------------------------------------------

---
-- Startup system after all nodes are brought into existence
local function startSystem()
   for name,n in pairs(nodes) do
      n:start(name)
   end
end

local function getConf()
   -- TODO: Find a configuration
end

local function configure(config)
   for cfgNode, classFactory in pairs {
      nmeaports = NmeaPort,
      rawports = RawPort,
      outputs = NmeaOutput,
      filter = NmeaFilter,
   }
   do
      for name, cfg in pairs(config[cfgNode] or {}) do
         assert(nodes[name] == nil)
         nodes[name] = classFactory(name, cfg)
      end
   end
end

local function main()
   local conf = getConf() or testConf or sampleConf
   configure(conf)
   startMonitor(117)
   startSystem()
end

return ac.ADDR_TRANSIENT, main
-- vim: set sw=3 sts=3 et nu:
